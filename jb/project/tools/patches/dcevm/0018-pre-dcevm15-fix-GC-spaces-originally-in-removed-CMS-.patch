From 1d682efa88c716e1849163d5abff3a3367581d16 Mon Sep 17 00:00:00 2001
From: Vladimir Dvorak <vladimir.dvorak@jetbrains.com>
Date: Mon, 16 Nov 2020 21:11:19 +0100
Subject: [PATCH 18/34] pre dcevm15 - fix GC spaces originally in removed CMS
 patch

---
 src/hotspot/share/gc/shared/space.cpp            | 16 ++++++++--------
 src/hotspot/share/gc/shared/space.hpp            |  6 +++---
 src/hotspot/share/gc/shared/space.inline.hpp     | 14 ++++++++------
 .../share/prims/jvmtiEnhancedRedefineClasses.cpp |  6 ++----
 4 files changed, 21 insertions(+), 21 deletions(-)

diff --git a/src/hotspot/share/gc/shared/space.cpp b/src/hotspot/share/gc/shared/space.cpp
index 875a6dc854f..9772c32c42e 100644
--- a/src/hotspot/share/gc/shared/space.cpp
+++ b/src/hotspot/share/gc/shared/space.cpp
@@ -375,11 +375,11 @@ HeapWord* CompactibleSpace::forward_compact_top(size_t size, CompactPoint* cp, H
 }
 
 HeapWord* CompactibleSpace::forward(oop q, size_t size,
-                                    CompactPoint* cp, HeapWord* compact_top) {
+                                    CompactPoint* cp, HeapWord* compact_top, bool force_forward) {
   compact_top = forward_compact_top(size, cp, compact_top);
 
   // store the forwarding pointer into the mark word
-  if (cast_from_oop<HeapWord*>(q) != compact_top || (size_t)q->size() != size) {
+  if (force_forward || cast_from_oop<HeapWord*>(q) != compact_top || (size_t)q->size() != size) {
     q->forward_to(oop(compact_top));
     assert(q->is_gc_marked(), "encoding the pointer should preserve the mark");
   } else {
@@ -501,7 +501,7 @@ bool CompactibleSpace::must_rescue(oop old_obj, oop new_obj) {
 
   } else {
     assert(space_index(old_obj) != space_index(new_obj), "old_obj and new_obj must be in different spaces");
-    if (tenured_gen->is_in_reserved(new_obj)) {
+    if (new_in_tenured) {
       // Must never rescue when moving from the new into the old generation.
       assert(GenCollectedHeap::heap()->young_gen()->is_in_reserved(old_obj), "old_obj must be in DefNewGeneration");
       assert(space_index(old_obj) > space_index(new_obj), "must be");
@@ -824,14 +824,14 @@ void OffsetTableContigSpace::verify() const {
 // Compute the forward sizes and leave out objects whose position could
 // possibly overlap other objects.
 HeapWord* CompactibleSpace::forward_with_rescue(HeapWord* q, size_t size,
-                                                CompactPoint* cp, HeapWord* compact_top) {
+                                                CompactPoint* cp, HeapWord* compact_top, bool force_forward) {
   size_t forward_size = size;
 
   // (DCEVM) There is a new version of the class of q => different size
   if (oop(q)->klass()->new_version() != NULL) {
 
     size_t new_size = oop(q)->size_given_klass(oop(q)->klass()->new_version());
-    assert(size != new_size, "instances without changed size have to be updated prior to GC run");
+    // assert(size != new_size, "instances without changed size have to be updated prior to GC run");
     forward_size = new_size;
   }
 
@@ -845,7 +845,7 @@ HeapWord* CompactibleSpace::forward_with_rescue(HeapWord* q, size_t size,
     return compact_top;
   }
 
-  return forward(oop(q), forward_size, cp, compact_top);
+  return forward(oop(q), forward_size, cp, compact_top, force_forward);
 }
 
 // Compute the forwarding addresses for the objects that need to be rescued.
@@ -861,11 +861,11 @@ HeapWord* CompactibleSpace::forward_rescued(CompactPoint* cp, HeapWord* compact_
       // (DCEVM) There is a new version of the class of q => different size
       if (oop(q)->klass()->new_version() != NULL) {
         size_t new_size = oop(q)->size_given_klass(oop(q)->klass()->new_version());
-        assert(size != new_size, "instances without changed size have to be updated prior to GC run");
+        // assert(size != new_size, "instances without changed size have to be updated prior to GC run");
         size = new_size;
       }
 
-      compact_top = cp->space->forward(oop(q), size, cp, compact_top);
+      compact_top = cp->space->forward(oop(q), size, cp, compact_top, true);
       assert(compact_top <= end(), "must not write over end of space!");
     }
     MarkSweep::_rescued_oops->clear();
diff --git a/src/hotspot/share/gc/shared/space.hpp b/src/hotspot/share/gc/shared/space.hpp
index c9bfc365f0f..f7648995454 100644
--- a/src/hotspot/share/gc/shared/space.hpp
+++ b/src/hotspot/share/gc/shared/space.hpp
@@ -405,7 +405,7 @@ public:
   virtual void prepare_for_compaction(CompactPoint* cp) = 0;
   // MarkSweep support phase3
   DEBUG_ONLY(int space_index(oop obj));
-  bool must_rescue(oop old_obj, oop new_obj);
+  virtual bool must_rescue(oop old_obj, oop new_obj);
   HeapWord* rescue(HeapWord* old_obj);
   virtual void adjust_pointers();
   // MarkSweep support phase4
@@ -436,11 +436,11 @@ public:
   // function of the then-current compaction space, and updates "cp->threshold
   // accordingly".
   virtual HeapWord* forward(oop q, size_t size, CompactPoint* cp,
-                    HeapWord* compact_top);
+                    HeapWord* compact_top, bool force_forward);
   // (DCEVM) same as forwad, but can rescue objects. Invoked only during
   // redefinition runs
   HeapWord* forward_with_rescue(HeapWord* q, size_t size, CompactPoint* cp,
-                                HeapWord* compact_top);
+                                HeapWord* compact_top, bool force_forward);
 
   HeapWord* forward_rescued(CompactPoint* cp, HeapWord* compact_top);
 
diff --git a/src/hotspot/share/gc/shared/space.inline.hpp b/src/hotspot/share/gc/shared/space.inline.hpp
index 5a93e93471b..fa645423685 100644
--- a/src/hotspot/share/gc/shared/space.inline.hpp
+++ b/src/hotspot/share/gc/shared/space.inline.hpp
@@ -163,6 +163,8 @@ inline void CompactibleSpace::scan_and_forward(SpaceType* space, CompactPoint* c
   HeapWord* cur_obj = space->bottom();
   HeapWord* scan_limit = space->scan_limit();
 
+  bool force_forward = false;
+
   while (cur_obj < scan_limit) {
     assert(!space->scanned_block_is_obj(cur_obj) ||
            oop(cur_obj)->mark_raw().is_marked() || oop(cur_obj)->mark_raw().is_unlocked() ||
@@ -174,14 +176,15 @@ inline void CompactibleSpace::scan_and_forward(SpaceType* space, CompactPoint* c
       size_t size = space->scanned_block_size(cur_obj);
 
       if (redefinition_run) {
-        compact_top = cp->space->forward_with_rescue(cur_obj, size, cp, compact_top);
+        compact_top = cp->space->forward_with_rescue(cur_obj, size, cp, compact_top, force_forward);
         if (first_dead == NULL && oop(cur_obj)->is_gc_marked()) {
           /* Was moved (otherwise, forward would reset mark),
              set first_dead to here */
           first_dead = cur_obj;
+          force_forward = true;
         }
       } else {
-        compact_top = cp->space->forward(oop(cur_obj), size, cp, compact_top);
+        compact_top = cp->space->forward(oop(cur_obj), size, cp, compact_top, false);
       }
 
       cur_obj += size;
@@ -197,9 +200,9 @@ inline void CompactibleSpace::scan_and_forward(SpaceType* space, CompactPoint* c
 
       // see if we might want to pretend this object is alive so that
       // we don't have to compact quite as often.
-      if (cur_obj == compact_top && dead_spacer.insert_deadspace(cur_obj, end)) {
+      if (!redefinition_run && cur_obj == compact_top && dead_spacer.insert_deadspace(cur_obj, end)) {
         oop obj = oop(cur_obj);
-        compact_top = cp->space->forward(obj, obj->size(), cp, compact_top);
+        compact_top = cp->space->forward(obj, obj->size(), cp, compact_top, force_forward);
         end_of_live = end;
       } else {
         // otherwise, it really is a free region.
@@ -362,8 +365,7 @@ inline void CompactibleSpace::scan_and_compact(SpaceType* space, bool redefiniti
       Prefetch::write(compaction_top, copy_interval);
 
       // copy object and reinit its mark
-      assert(cur_obj != compaction_top || oop(cur_obj)->klass()->new_version() != NULL,
-             "everything in this pass should be moving");
+      assert(redefinition_run || cur_obj != compaction_top, "everything in this pass should be moving");
       if (redefinition_run && oop(cur_obj)->klass()->new_version() != NULL) {
         Klass* new_version = oop(cur_obj)->klass()->new_version();
         if (new_version->update_information() == NULL) {
diff --git a/src/hotspot/share/prims/jvmtiEnhancedRedefineClasses.cpp b/src/hotspot/share/prims/jvmtiEnhancedRedefineClasses.cpp
index 718426f2819..1da6661dd3e 100644
--- a/src/hotspot/share/prims/jvmtiEnhancedRedefineClasses.cpp
+++ b/src/hotspot/share/prims/jvmtiEnhancedRedefineClasses.cpp
@@ -431,13 +431,11 @@ public:
       Klass* new_klass = obj->klass()->new_version();
 
       if (new_klass->update_information() != NULL) {
-        int size_diff = obj->size() - obj->size_given_klass(new_klass);
-
-        // Either new size is bigger or gap is to small to be filled
-        if (size_diff < 0 || (size_diff > 0 && (size_t) size_diff < CollectedHeap::min_fill_size())) {
+        if (obj->size() - obj->size_given_klass(new_klass) != 0) {
           // We need an instance update => set back to old klass
           _needs_instance_update = true;
         } else {
+          // Either new size is bigger or gap is to small to be filled
           oop src = obj;
           if (new_klass->is_copying_backwards()) {
             copy_to_tmp(obj);
-- 
2.23.0

