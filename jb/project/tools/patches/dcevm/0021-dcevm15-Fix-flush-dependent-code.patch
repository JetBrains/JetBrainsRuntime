From cea4e2cca3c37233c728be7235f8f9d8be136cb5 Mon Sep 17 00:00:00 2001
From: Vladimir Dvorak <vladimir.dvorak@jetbrains.com>
Date: Tue, 17 Nov 2020 18:52:57 +0100
Subject: [PATCH 21/34] dcevm15 - Fix flush dependent code

---
 .../prims/jvmtiEnhancedRedefineClasses.cpp    | 57 +++++++------------
 .../prims/jvmtiEnhancedRedefineClasses.hpp    |  4 +-
 2 files changed, 25 insertions(+), 36 deletions(-)

diff --git a/src/hotspot/share/prims/jvmtiEnhancedRedefineClasses.cpp b/src/hotspot/share/prims/jvmtiEnhancedRedefineClasses.cpp
index 619e3988e3a..efaf11e1666 100644
--- a/src/hotspot/share/prims/jvmtiEnhancedRedefineClasses.cpp
+++ b/src/hotspot/share/prims/jvmtiEnhancedRedefineClasses.cpp
@@ -508,7 +508,7 @@ void VM_EnhancedRedefineClasses::doit() {
 
   // Deoptimize all compiled code that depends on this class (do only once, because it clears whole cache)
   // if (_max_redefinition_flags > Klass::ModifyClass) {
-    flush_dependent_code(NULL, thread);
+    flush_dependent_code(thread);
   // }
 
     // Adjust constantpool caches for all classes that reference methods of the evolved class.
@@ -647,17 +647,8 @@ void VM_EnhancedRedefineClasses::doit() {
   //MethodDataCleaner clean_weak_method_links;
   //ClassLoaderDataGraph::classes_do(&clean_weak_method_links);
 
-  // Disable any dependent concurrent compilations
-  // SystemDictionary::notice_modification();
-
   JvmtiExport::increment_redefinition_count();
 
-  // Set flag indicating that some invariants are no longer true.
-  // See jvmtiExport.hpp for detailed explanation.
-
-  // dcevm15: handled by _redefinition_count
-  // JvmtiExport::set_has_redefined_a_class();
-
 #ifdef PRODUCT
   if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
 #endif
@@ -1746,6 +1737,18 @@ void VM_EnhancedRedefineClasses::transfer_old_native_function_registrations(Inst
   transfer.transfer_registrations(_matching_old_methods, _matching_methods_length);
 }
 
+// First step is to walk the code cache for each class redefined and mark
+// dependent methods.  Wait until all classes are processed to deoptimize everything.
+void VM_EnhancedRedefineClasses::mark_dependent_code(InstanceKlass* ik) {
+  assert_locked_or_safepoint(Compile_lock);
+
+  // All dependencies have been recorded from startup or this is a second or
+  // subsequent use of RedefineClasses
+  if (0 && JvmtiExport::all_dependencies_are_recorded()) {
+    CodeCache::mark_for_evol_deoptimization(ik);
+  }
+}
+
 // DCEVM - it always deoptimizes everything! (because it is very difficult to find only correct dependencies)
 // Deoptimize all compiled code that depends on this class.
 //
@@ -1762,33 +1765,21 @@ void VM_EnhancedRedefineClasses::transfer_old_native_function_registrations(Inst
 // subsequent calls to RedefineClasses need only throw away code
 // that depends on the class.
 //
-void VM_EnhancedRedefineClasses::flush_dependent_code(InstanceKlass* k_h, TRAPS) {
+void VM_EnhancedRedefineClasses::flush_dependent_code(TRAPS) {
   assert_locked_or_safepoint(Compile_lock);
 
   // All dependencies have been recorded from startup or this is a second or
   // subsequent use of RedefineClasses
   // FIXME: for now, deoptimize all!
-  if (0 && k_h != NULL && JvmtiExport::all_dependencies_are_recorded()) {
-    CodeCache::flush_evol_dependents_on(k_h);
-    Klass* superCl = k_h->super();
-    // Deoptimize super classes since redefined class can has a new method override
-    while (superCl != NULL && !superCl->is_redefining()) {
-      CodeCache::flush_evol_dependents_on(InstanceKlass::cast(superCl));
-      superCl = superCl->super();
+  if (0 && JvmtiExport::all_dependencies_are_recorded()) {
+    int deopt = CodeCache::mark_dependents_for_evol_deoptimization();
+    log_debug(redefine, class, nmethod)("Marked %d dependent nmethods for deopt", deopt);
+    if (deopt != 0) {
+      CodeCache::flush_evol_dependents();
     }
   } else {
-    CodeCache::mark_all_nmethods_for_deoptimization();
-
-    ResourceMark rm(THREAD);
-    DeoptimizationMarker dm;
-
-    // Deoptimize all activations depending on marked nmethods
-    Deoptimization::deoptimize_dependents();
-
-    // Make the dependent methods not entrant
-    CodeCache::make_marked_nmethods_not_entrant();
-
-    // From now on we know that the dependency information is complete
+    CodeCache::mark_all_nmethods_for_evol_deoptimization();
+    CodeCache::flush_evol_dependents();
     JvmtiExport::set_all_dependencies_are_recorded(true);
   }
 }
@@ -1881,11 +1872,7 @@ void VM_EnhancedRedefineClasses::redefine_single_class(InstanceKlass* new_class_
   JvmtiBreakpoints& jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
   jvmti_breakpoints.clearall_in_class_at_safepoint(the_class);
 
-  // DCEVM Deoptimization is always for whole java world, call only once after all classes are redefined
-  // Deoptimize all compiled code that depends on this class
-//  if (_max_redefinition_flags <= Klass::ModifyClass) {
-//    flush_dependent_code(the_class, THREAD);
-//  }
+  mark_dependent_code(the_class);
 
   _old_methods = the_class->methods();
   _new_methods = new_class->methods();
diff --git a/src/hotspot/share/prims/jvmtiEnhancedRedefineClasses.hpp b/src/hotspot/share/prims/jvmtiEnhancedRedefineClasses.hpp
index 0066088b3b0..bd5e7d153be 100644
--- a/src/hotspot/share/prims/jvmtiEnhancedRedefineClasses.hpp
+++ b/src/hotspot/share/prims/jvmtiEnhancedRedefineClasses.hpp
@@ -142,7 +142,9 @@ class VM_EnhancedRedefineClasses: public VM_GC_Operation {
   // and in all direct and indirect subclasses.
   void increment_class_counter(InstanceKlass *ik, TRAPS);
 
-  void flush_dependent_code(InstanceKlass* k_h, TRAPS);
+  void mark_dependent_code(InstanceKlass* ik);
+
+  void flush_dependent_code(TRAPS);
 
   u8 next_id();
 
-- 
2.23.0

